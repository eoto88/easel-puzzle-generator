EASEL = {};

// Generated by CoffeeScript 1.7.1
(function() {
  EASEL.matrix = function(a, b, c, d, tx, ty) {
    var inverse, isIdentity, premultipliedBy, rotatedBy, scaledBy, that, toArray, transformedPoint, translatedBy;
    if (a == null) {
      a = 1;
    }
    if (b == null) {
      b = 0;
    }
    if (c == null) {
      c = 0;
    }
    if (d == null) {
      d = 1;
    }
    if (tx == null) {
      tx = 0;
    }
    if (ty == null) {
      ty = 0;
    }
    that = {};
    isIdentity = function() {
      return a === 1 && b === 0 && c === 0 && d === 1 && tx === 0 && ty === 0;
    };
    translatedBy = function(x, y) {
      return premultipliedBy(EASEL.matrix(1, 0, 0, 1, x, y));
    };
    scaledBy = function(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        throw new Error("Inputs to #scaledBy must by numbers: x=" + x + ", y=" + y);
      }
      return premultipliedBy(EASEL.matrix(x, 0, 0, y, 0, 0));
    };
    rotatedBy = function(angle) {
      var cos, sin;
      cos = Math.cos(angle);
      sin = Math.sin(angle);
      return premultipliedBy(EASEL.matrix(cos, sin, -sin, cos, 0, 0));
    };
    premultipliedBy = function(matrix) {
      var _a, _b, _c, _d, _ref, _tx, _ty;
      _ref = matrix.toArray(), _a = _ref[0], _b = _ref[1], _c = _ref[2], _d = _ref[3], _tx = _ref[4], _ty = _ref[5];
      return EASEL.matrix(_a * a + _c * b, _b * a + _d * b, _a * c + _c * d, _b * c + _d * d, _a * tx + _c * ty + _tx, _b * tx + _d * ty + _ty);
    };
    inverse = function() {
      var scale, scaleInverse, x, y, _a, _b, _c, _d, _ref, _ref1;
      scale = 1 / (a * d - b * c);
      scaleInverse = EASEL.matrix(scale * d, -scale * b, -scale * c, scale * a, 0, 0);
      _ref = scaleInverse.transformedPoint({
        x: tx,
        y: ty
      }), x = _ref.x, y = _ref.y;
      _ref1 = scaleInverse.toArray(), _a = _ref1[0], _b = _ref1[1], _c = _ref1[2], _d = _ref1[3];
      return EASEL.matrix(_a, _b, _c, _d, -x, -y);
    };
    transformedPoint = function(point) {
      return {
        x: a * point.x + c * point.y + tx,
        y: b * point.x + d * point.y + ty
      };
    };
    toArray = function() {
      return [a, b, c, d, tx, ty];
    };
    that.isIdentity = isIdentity;
    that.translatedBy = translatedBy;
    that.scaledBy = scaledBy;
    that.rotatedBy = rotatedBy;
    that.premultipliedBy = premultipliedBy;
    that.transformedPoint = transformedPoint;
    that.inverse = inverse;
    that.toArray = toArray;
    return that;
  };

}).call(this);

(function() {
  EASEL.math = (function() {
    var add, clamp, dist2, distToSegment, distance, moveToward, scaleTo, sqr, sub;
    clamp = function(value, min, max) {
      return Math.min(max, Math.max(min, value));
    };
    sqr = function(x) {
      return x * x;
    };
    dist2 = function(v, w) {
      return sqr(v.x - w.x) + sqr(v.y - w.y);
    };
    distance = function(v1, v2) {
      return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.y - v2.y, 2));
    };
    distToSegment = function(p, v, w) {
      var l2, projectedPoint, t;
      l2 = dist2(v, w);
      if (l2 === 0) {
        return {
          distance: distance(p, v),
          point: v
        };
      }
      t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
      switch (false) {
        case !(t < 0):
          return {
            distance: distance(p, v),
            point: v
          };
        case !(t > 1):
          return {
            distance: distance(p, w),
            point: w
          };
        default:
          projectedPoint = {
            x: v.x + t * (w.x - v.x),
            y: v.y + t * (w.y - v.y)
          };
          return {
            distance: distance(p, projectedPoint),
            point: projectedPoint
          };
      }
    };
    sub = function(v1, v2) {
      return {
        x: v1.x - v2.x,
        y: v1.y - v2.y
      };
    };
    add = function(v1, v2) {
      return {
        x: v1.x + v2.x,
        y: v1.y + v2.y
      };
    };
    scaleTo = function(v, length) {
      var scale;
      scale = length / distance(v, {
        x: 0,
        y: 0
      });
      return {
        x: v.x * scale,
        y: v.y * scale
      };
    };
    moveToward = function(p1, p2, dist) {
      return add(p1, scaleTo(sub(p2, p1), dist));
    };
    return {
      clamp: clamp,
      distance: distance,
      distToSegment: distToSegment,
      moveToward: moveToward
    };
  })();

}).call(this);

(function() {
  EASEL.subdivider = (function() {
    var cache, fingerprint, maxError, pointOnLineSegment, splitCubicBezier, subdivide, subdivideCubicBezier, that;
    that = {};
    cache = {};
    fingerprint = function(curve, err) {
      var points;
      points = curve.map(function(p) {
        return "" + p.x + "_" + p.y;
      }).join("-");
      return "" + points + "-" + err;
    };
    maxError = function(curve) {
      var dist1, dist2, end, start;
      start = curve[0];
      end = curve[curve.length - 1];
      dist1 = EASEL.math.distToSegment(curve[1], start, end).distance;
      dist2 = EASEL.math.distToSegment(curve[2], start, end).distance;
      return Math.max(dist1, dist2) * 0.75;
    };
    subdivide = function(curve, split, err) {
      var l, r, _ref;
      if (maxError(curve) < err) {
        return [curve[curve.length - 1]];
      } else {
        _ref = split(curve), l = _ref.l, r = _ref.r;
        return subdivide(l, split, err).concat(subdivide(r, split, err));
      }
    };
    subdivideCubicBezier = function(start, control1, control2, end, err) {
      var curve, _name;
      curve = [start, control1, control2, end];
      return cache[_name = fingerprint(curve, err)] != null ? cache[_name] : cache[_name] = subdivide(curve, splitCubicBezier, err);
    };
    pointOnLineSegment = function(t, start, end) {
      var p, u;
      u = 1 - t;
      return p = {
        x: start.x * u + end.x * t,
        y: start.y * u + end.y * t
      };
    };
    splitCubicBezier = function(curve) {
      var control1, control2, end, join, l1, l2, m, r1, r2, result, start;
      start = curve[0], control1 = curve[1], control2 = curve[2], end = curve[3];
      l1 = pointOnLineSegment(0.5, start, control1);
      m = pointOnLineSegment(0.5, control1, control2);
      r2 = pointOnLineSegment(0.5, control2, end);
      l2 = pointOnLineSegment(0.5, l1, m);
      r1 = pointOnLineSegment(0.5, m, r2);
      join = pointOnLineSegment(0.5, l2, r1);
      return result = {
        l: [start, l1, l2, join],
        r: [join, r1, r2, end]
      };
    };
    that.subdivideCubicBezier = subdivideCubicBezier;
    return that;
  })();

}).call(this);

(function() {
  EASEL.pathNormalizer = (function() {
    var absolutize, isRelative, lastX, lastY, offsetSingle, offsetXY, process, startX, startY, that;
    that = {};
    startX = null;
    startY = null;
    lastX = null;
    lastY = null;
    isRelative = function(path) {
      return path[0] === path[0].toLowerCase();
    };
    offsetXY = function(path, offsetX, offsetY) {
      var i, pointList, _, _i, _len;
      pointList = path.slice(1);
      for (i = _i = 0, _len = pointList.length; _i < _len; i = _i += 2) {
        _ = pointList[i];
        path[i + 1] = pointList[i] + offsetX;
        path[i + 2] = pointList[i + 1] + offsetY;
      }
      return path;
    };
    offsetSingle = function(path, offset) {
      var i, point, _i, _len, _ref;
      _ref = path.slice(1);
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        point = _ref[i];
        path[i + 1] = point + offset;
      }
      return path;
    };
    absolutize = function(path) {
      if (isRelative(path)) {
        path[0] = path[0].toUpperCase();
        path = (function() {
          switch (path[0]) {
            case 'H':
              return offsetSingle(path, lastX);
            case 'V':
              return offsetSingle(path, lastY);
            default:
              return offsetXY(path, lastX, lastY);
          }
        })();
      }
      if (path[0] === 'M') {
        startX = path[1];
        startY = path[2];
      }
      lastX = (function() {
        switch (path[0]) {
          case 'H':
            return path[1];
          case 'V':
            return lastX;
          case 'Z':
            return startX;
          default:
            return path[path.length - 2];
        }
      })();
      lastY = (function() {
        switch (path[0]) {
          case 'H':
            return lastY;
          case 'V':
            return path[1];
          case 'Z':
            return startY;
          default:
            return path[path.length - 1];
        }
      })();
      return path;
    };
    process = function(commands) {
      var command, _i, _len, _results;
      lastX = lastY = 0;
      _results = [];
      for (_i = 0, _len = commands.length; _i < _len; _i++) {
        command = commands[_i];
        _results.push(absolutize(command.slice(0)));
      }
      return _results;
    };
    that.process = process;
    return that;
  })();
}).call(this);

EASEL.pathStringParser = (function() {
  var that = {}

  var commandLengths = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7
  };

  var repeatedCommands = {
    m: 'l',
    M: 'L'
  };

  var parse = function(string) {
    var path = string.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
    var result = [ ],
        coords = [ ],
        currentPath,
        parsed,
        re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
        match,
        coordsStr;

    for (var i = 0, coordsParsed, len = path.length; i < len; i++) {
      currentPath = path[i];

      coordsStr = currentPath.slice(1).trim();
      coords.length = 0;

      while ((match = re.exec(coordsStr))) {
        coords.push(match[0]);
      }

      coordsParsed = [ currentPath.charAt(0) ];

      for (var j = 0, jlen = coords.length; j < jlen; j++) {
        parsed = parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          coordsParsed.push(parsed);
        }
      }

      var command = coordsParsed[0],
          commandLength = commandLengths[command.toLowerCase()],
          repeatedCommand = repeatedCommands[command] || command;

      if (coordsParsed.length - 1 > commandLength) {
        for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
          result.push([ command ].concat(coordsParsed.slice(k, k + commandLength)));
          command = repeatedCommand;
        }
      }
      else {
        result.push(coordsParsed);
      }
    }

    return result;
  }

  that.parse = parse;

  return that;
})();


(function() {
  EASEL.pathPolylineGenerator = function(maxError, matrix) {
    var bezierWithRelativeControls, move, that, toPolyline, toPolylines, zero;
    that = {};
    zero = {
      x: 0,
      y: 0
    };
    move = function(point) {
      return [matrix.transformedPoint(point)];
    };
    bezierWithRelativeControls = function(start, c1, c2, end) {
      if (c1 == null) {
        c1 = zero;
      }
      if (c2 == null) {
        c2 = zero;
      }
      c1 = {
        x: start.x + c1.x,
        y: start.y + c1.y
      };
      c2 = {
        x: end.x + c2.x,
        y: end.y + c2.y
      };
      return EASEL.subdivider.subdivideCubicBezier(matrix.transformedPoint(start), matrix.transformedPoint(c1), matrix.transformedPoint(c2), matrix.transformedPoint(end), maxError);
    };
    toPolyline = function(points) {
      var point, previousPoint, result, _i, _len;
      result = [];
      previousPoint = null;
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        if ((previousPoint != null) && ((previousPoint.rh != null) || (point.lh != null))) {
          result = result.concat(bezierWithRelativeControls(previousPoint, previousPoint.rh, point.lh, point));
        } else {
          result = result.concat(move(point));
        }
        previousPoint = point;
      }
      return result;
    };
    toPolylines = function(pointArrays) {
      var subpathPoints, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pointArrays.length; _i < _len; _i++) {
        subpathPoints = pointArrays[_i];
        _results.push(toPolyline(subpathPoints));
      }
      return _results;
    };
    that.toPolyline = toPolyline;
    that.toPolylines = toPolylines;
    return that;
  };

}).call(this);

(function() {
  EASEL.pathToControlPoints = function(pathComponents) {
    var addPoint, arc, close, commandMapping, cubicBezier, currentSubpath, horizontal, lastCubicControl, lastPoint, lastQuadraticControl, line, move, pathStart, quadraticBezier, reflectedCubicBezier, reflectedQuadraticBezier, result, setLastCubicControl, setLastQuadraticControl, vertical;
    result = [];
    currentSubpath = [];
    lastPoint = {
      x: 0,
      y: 0
    };
    lastQuadraticControl = {
      x: null,
      y: null
    };
    lastCubicControl = {
      x: null,
      y: null
    };
    pathStart = null;
    move = function(endX, endY) {
      if (currentSubpath.length > 1) {
        result.push(currentSubpath);
      }
      currentSubpath = [];
      addPoint(endX, endY);
      return pathStart = {
        x: endX,
        y: endY
      };
    };
    close = function() {
      if (pathStart) {
        addPoint(pathStart.x, pathStart.y);
      }
      if (currentSubpath.length > 2) {
        result.push(currentSubpath);
      }
      currentSubpath = [];
      return addPoint(pathStart.x, pathStart.y);
    };
    line = function(endX, endY) {
      return addPoint(endX, endY);
    };
    vertical = function(endY) {
      return addPoint(lastPoint.x, endY);
    };
    horizontal = function(endX) {
      return addPoint(endX, lastPoint.y);
    };
    cubicBezier = function(c1X, c1Y, c2X, c2Y, endX, endY) {
      lastPoint.rh = {
        x: c1X - lastPoint.x,
        y: c1Y - lastPoint.y
      };
      addPoint(endX, endY);
      lastPoint.lh = {
        x: c2X - lastPoint.x,
        y: c2Y - lastPoint.y
      };
      return setLastCubicControl(c2X, c2Y);
    };
    quadraticBezier = function(c1X, c1Y, endX, endY) {
      lastPoint.rh = {
        x: (2 / 3) * (c1X - lastPoint.x),
        y: (2 / 3) * (c1Y - lastPoint.y)
      };
      addPoint(endX, endY);
      lastPoint.lh = {
        x: (2 / 3) * (c1X - lastPoint.x),
        y: (2 / 3) * (c1Y - lastPoint.y)
      };
      return setLastQuadraticControl(c1X, c1Y);
    };
    reflectedCubicBezier = function(c2X, c2Y, endX, endY) {
      var c1X, c1Y;
      c1X = lastCubicControl.x != null ? 2 * lastPoint.x - lastCubicControl.x : lastPoint.x;
      c1Y = lastCubicControl.y != null ? 2 * lastPoint.y - lastCubicControl.y : lastPoint.y;
      return cubicBezier(c1X, c1Y, c2X, c2Y, endX, endY);
    };
    reflectedQuadraticBezier = function(endX, endY) {
      var c1X, c1Y;
      c1X = lastQuadraticControl.x != null ? 2 * lastPoint.x - lastQuadraticControl.x : lastPoint.x;
      c1Y = lastQuadraticControl.y != null ? 2 * lastPoint.y - lastQuadraticControl.y : lastPoint.y;
      return quadraticBezier(c1X, c1Y, endX, endY);
    };
    arc = function(rx, ry, xAxisRotation, largeArc, sweep, end) {
      return console.error("Path command error: arc not implemented");
    };
    addPoint = function(x, y) {
      var point;
      point = {
        x: x,
        y: y
      };
      currentSubpath.push(point);
      lastPoint = point;
      setLastCubicControl(null, null);
      return setLastQuadraticControl(null, null);
    };
    setLastCubicControl = function(x, y) {
      lastCubicControl.x = x;
      return lastCubicControl.y = y;
    };
    setLastQuadraticControl = function(x, y) {
      lastQuadraticControl.x = x;
      return lastQuadraticControl.y = y;
    };
    commandMapping = {
      'M': move,
      'Z': close,
      'L': line,
      'V': vertical,
      'H': horizontal,
      'C': cubicBezier,
      'S': reflectedCubicBezier,
      'Q': quadraticBezier,
      'T': reflectedQuadraticBezier,
      'A': arc
    };
    return (function() {
      var component, _i, _len;
      pathComponents = EASEL.pathNormalizer.process(pathComponents);
      for (_i = 0, _len = pathComponents.length; _i < _len; _i++) {
        component = pathComponents[_i];
        commandMapping[component[0]].apply(commandMapping, component.slice(1));
      }
      if (currentSubpath.length > 1) {
        result.push(currentSubpath);
      }
      return result;
    })();
  };

}).call(this);
